Name: abc-genbank
Description: ABC on Genbank data sets with preferential attachment graphs
Processes: 1
Sleep: 5
Memory: 256m
Steps:
    raw-uid:
        Extension: tsv.bz2
        Walltime: 03:00:00
        Parameters:
            query: "human+immunodeficiency+virus+1[porgn]"
            date: "16-01-18"
        Interpreter: python3
        Startup: |
            from Bio import Entrez
            import bz2
        Rule: |
            retmax = 10000
            Entrez.email = "rmccloskey@cfenet.ubc.ca"
            handle = Entrez.esearch(db="nuccore", retmax=retmax, term="{query}",
                                    useHistory=True)
            record = Entrez.read(handle) 
            env = record["WebEnv"]
            key = record["QueryKey"]
            count = int(record["Count"])

            retstart = 0
            outfile = bz2.open("{raw-uid}", "w")
            while retstart < count:
                handle = Entrez.esearch(db="nuccore", retstart=retstart, term="{query}",
                                        retmax=retmax, QueryKey=key, WebEnv=env)
                record = Entrez.read(handle)
                for id in record["IdList"]:
                    outfile.write(bytes(id, "UTF-8") + b"\n")
                retstart += retmax
                outfile.flush()
            outfile.close()

    raw-fasta:
        Extension: tar.bz2
        Walltime: 024:00:00
        Parameters:
            query: "human+immunodeficiency+virus+1[porgn]"
        Interpreter: python3
        Depends: raw-uid
        Startup: |
            from Bio import Entrez
            import os
            import itertools
            import tarfile
            import bz2
            import subprocess
        Rule: |
            Entrez.email = "rmccloskey@cfenet.ubc.ca"

            if os.path.exists("{raw-fasta}"):
                subprocess.run(["bunzip2", "{raw-fasta}"])

            def grouper(iterable, n, fillvalue=None):
                args = [iter(iterable)] * n
                return itertools.zip_longest(*args, fillvalue=fillvalue)

            id_file = bz2.open("{raw-uid}", "rt")
            outfile = tarfile.open("{raw-fasta}".replace(".bz2", ""), "a")
            outdir = os.path.dirname("{raw-fasta}")
            names = set([x.replace(".fasta", "") for x in outfile.getnames()])
            ids = set([line.strip() for line in id_file])
            ids = ids - names
            id_file.close()

            for ids in grouper(ids, 1000):
                ids = [x for x in ids if x is not None]
                print("Fetching {{}} records".format(len(ids)))
                handle = Entrez.efetch(db="nuccore", id=",".join(ids), 
                                       rettype="fasta", retmode="text")
                
                fasta = None
                for line in handle:
                    if line.startswith(">"):
                        if fasta is not None:
                            fasta.close()
                            outfile.add(fasta.name, arcname=os.path.basename(fasta.name))
                            os.unlink(fasta.name)
                        id = line.split("|")[1]
                        fasta = open(os.path.join(outdir, "{{}}.fasta".format(id)), "w")
                    if len(line) > 1:
                        fasta.write(line)

                if fasta is not None:
                    fasta.close()
                    outfile.add(fasta.name, arcname=os.path.basename(fasta.name))
                    os.unlink(fasta.name)

            outfile.close()
            subprocess.call(["bzip2", "{raw-fasta}".replace(".bz2", "")])

    hxb2:
        Extension: fasta
        Interpreter: python3
        Parameters:
            placeholder: 0
        Startup: |
            from Bio import Entrez
            Entrez.email = "rmccloskey@cfenet.ubc.ca"
        Rule: |
            handle = Entrez.efetch("nuccore", id="1906382", rettype="fasta", retmode="text")
            with open("{hxb2}", "w") as f:
                for line in handle:
                    if len(line) > 1:
                        f.write(line)

    coverage:
        Extension: tsv
        Walltime: 09:00:00
        Parameters:
            query: "human+immunodeficiency+virus+1[porgn]"
            max_del: 100
            min_length: 80
        Interpreter: python3
        Depends: raw-fasta hxb2
        Startup: |
            from Bio import SeqIO, AlignIO
            import subprocess
            import tarfile
            import sys
            import os
            import io
        Rule: |
            hxb2 = SeqIO.read("{hxb2}", "fasta")
            infile = tarfile.open("{raw-fasta}")

            outfile = open("{coverage}")
            done = set([line.split("\t")[0] for line in outfile])
            outfile.close()

            outfile = open("{coverage}", "a")
            for fasta in infile:
                if fasta.name.replace(".fasta", "") in done:
                    sys.stderr.write("Sequence {{}} is already done\n".format(fasta.name.replace(".fasta", "")))
                    continue
                infile.extract(fasta)
                with open(fasta.name, "a") as f:
                    SeqIO.write(hxb2, f, "fasta")
                proc = subprocess.Popen(["mafft", "--inputorder", fasta.name], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, universal_newlines=True)
                buf = io.StringIO(proc.communicate()[0])
                os.unlink(fasta.name)
                try:
                    al = AlignIO.read(buf, "fasta")
                except ValueError:
                    sys.stderr.write("Failed to align sequence {{}}\n".format(fasta.name.replace(".fasta", "")))
                    continue
                
                positions = []
                cur = 1
                for i in range(len(al[1])):
                    if al[1,i] != "-":
                        if al[0,i] != "-":
                            positions.append(cur)
                        cur += 1
                
                start = positions.pop(0)
                intervals = [[start, start]]
                while len(positions) > 0:
                    next = positions.pop(0)
                    if next == intervals[-1][1] + 1:
                        intervals[-1][1] = next
                    else:
                        intervals.append([next, next])
                        
                merged = [intervals[0]]
                for i in range(1, len(intervals)):
                    if intervals[i][0] - merged[-1][1] < {max_del}:
                        merged[-1][1] = intervals[i][1]
                    else:
                        merged.append(intervals[i])
                merged = [x for x in merged if x[1] - x[0] >= {min_length}]
                
                id = fasta.name.replace(".fasta", "")
                for interval in merged:
                    outfile.write("{{}}\t{{}}\t{{}}\n".format(id, interval[0], interval[1]))
                outfile.flush()
