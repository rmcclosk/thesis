Name: kernel-pareto
Description: Testing if the tree kernel can distinguish between Pareto degree distribution parameters
Processes: 3
Steps:
    network:
        Extension: gml
        Parameters:
            nnode: 5000
            pareto_shape: [1, 1.5, 2]
            seed: !!python/object/apply:__builtin__.xrange [0, 100, 1]
        Interpreter: R --vanilla --silent
        Startup: |
            suppressPackageStartupMessages(library(netabc))
            suppressPackageStartupMessages(library(igraph))
            suppressPackageStartupMessages(library(VGAM))
        Rule: | 
            set.seed({seed} + {pareto_shape} * 100)
            g <- sample_degseq(2, method="simple")
            while (any(which_loop(g)) | any(which_multiple(g))) 
            {{
                s <- 1
                while (!is_graphical(s)) {{
                    s <- round(rpareto({nnode}, shape={pareto_shape}))
                }}
                g <- tryCatch({{sample_degseq(s, method="vl")}},
                              error = function (e) sample_degseq(2, method="simple"))
                                
            }}
            graph_attr(g, "comment") <- "{yaml}"
            write.graph(SI.net(g), "{network}", format="gml")

    tree:
        Extension: nwk
        Parameters:
            nnode: 5000
            pareto_shape: [1, 1.5, 2]
            ntip: [100, 500, 1000]
            nsimnode: 1000
            seed: !!python/object/apply:__builtin__.xrange [0, 100, 1]
        Depends: network
        Interpreter: bash
        Rule: |
            echo "#{yaml}" > {tree}
            nettree --sim-nodes {nsimnode} --tree-tips {ntip} --seed `echo {seed}+{pareto_shape}*100 | bc` {network} >> {tree}
            i=0
            while [[ `treestat -i -s ntip {tree}` -lt {ntip} ]]; do
                echo "#{yaml}" > {tree}
                nettree --sim-nodes {nsimnode} --tree-tips {ntip} --seed `echo {seed}+{pareto_shape}*\(100+$i\) | bc` {network} >> {tree}
                i=$(($i+1))
            done

    statistics:
        Extension: tsv
        Parameters:
            ntip: [100, 500, 1000]
        Depends: tree
        Interpreter: bash
        Rule: |
            echo "#{yaml}" > {statistics}
            echo -e "colless\til.portion\tmax.ladder\tdepth\tbmi\tdelta.w\twidth\tcherries\tprop.unbalanced\tavg.unbalance\tsackin\tcophenetic\tgamma" >> {statistics}
            for T in {tree}; do
                echo -n `treestat -i -y -s colless $T`$'\t' >> {statistics}
                echo -n `treestat -i -n -s il $T`$'\t' >> {statistics}
                echo -n `treestat -i -n -s ladder $T`$'\t' >> {statistics}
                echo -n `treestat -i -n -s height $T`$'\t' >> {statistics}
                echo -n `treestat -i -s bmi $T`$'\t' >> {statistics}
                echo -n `treestat -i -n -s max-delta-width $T`$'\t' >> {statistics}
                echo -n `treestat -i -n -s width $T`$'\t' >> {statistics}
                echo -n `treestat -i -n -s cherries $T`$'\t' >> {statistics}
                echo -n `treestat -i -s prop-unbalanced $T`$'\t' >> {statistics}
                echo -n `treestat -i -s unbalance $T`$'\t' >> {statistics}
                echo -n `treestat -i -y -s sackin $T`$'\t' >> {statistics}
                echo -n `treestat -i -y -s cophenetic $T`$'\t' >> {statistics}
                echo `treestat -i -s gamma $T` >> {statistics}
            done

    stats-plot:
        Extension: pdf
        Parameters:
            ntip: [100, 500, 1000]
        Depends: statistics tree
        Interpreter: R --vanilla --silent
        Startup: |
            library(netabc)
            library(reshape2)
        Rule: |
            m <- collect.metadata(strsplit("{tree}", " ")[[1]])[,"pareto_shape"]
            d <- read.table("{statistics}", header=TRUE)
            d <- cbind(pareto.shape=as.factor(m), d)
            d <- melt(d, id.vars="pareto.shape")
            ggplot(d, aes(x=pareto.shape, y=value)) + geom_violin() + facet_wrap(~variable, scales="free") + theme_bw()
            ggsave("{stats-plot}")

    kernel-matrix:
        Extension: mtx
        Parameters:
            ntip: [100, 500, 1000]
            branch_scaling: mean
            decay_factor: [0.2, 0.3, 0.4, 0.5]
            rbf_variance: [0.5, 1, 2, 5, 10, 20]
        Depends: tree
        Interpreter: bash
        Rule: |
            echo "%%MatrixMarket matrix array real symmetric" > {kernel-matrix}
            echo "%{yaml}" >> {kernel-matrix}
            echo "{$#} {$#}" >> {kernel-matrix}
            for T1 in {tree}; do
                for T2 in {tree}; do
                    if [[ "$T1" < "$T2" || "$T1" == "$T2" ]]; then
                    treekernel --ladderize --decay-factor {decay_factor} \
                               --gauss-factor {rbf_variance} \
                               --scale-branches {branch_scaling} \
                               --sst-control 1 $T1 $T2 >> {kernel-matrix}
                    fi
                done
            done

    kpca-plot:
        Extension: pdf
        Parameters:
            ntip: [100, 500, 1000]
            branch_scaling: mean
            decay_factor: [0.2, 0.3, 0.4, 0.5]
            rbf_variance: [0.5, 1, 2, 5, 10, 20]
        Depends: kernel-matrix tree
        Interpreter: R --vanilla --silent
        Startup: library(netabc)
        Rule: |
            k <- read.mm("{kernel-matrix}")
            y <- as.factor(collect.metadata(strsplit("{tree}", " ")[[1]])[,"pareto_shape"])
            kpca.plot(k, color=list(pareto.shape=y), yaml="{yaml}")
            ggsave("{kpca-plot}")

    classifier:
        Extension: tsv
        Parameters:
            ntip: [100, 500, 1000]
            branch_scaling: mean
            decay_factor: [0.2, 0.3, 0.4, 0.5]
            rbf_variance: [0.5, 1, 2, 5, 10, 20]
            ncrossv: 1000
            response: ["continuous"]
        Depends: kernel-matrix tree
        Interpreter: R --vanilla --silent
        Startup: suppressPackageStartupMessages(library(netabc))
        Rule: |
            k <- read.mm("{kernel-matrix}")
            y <- collect.metadata(strsplit("{tree}", " ")[[1]])[,"pareto_shape"]
            if ("{response}" == "continuous") {{
                results <- ksvm.cv(k, y, n.cv={ncrossv}, stats=c("rsquared"))
            }} else {{
                y <- as.factor(y)
                results <- ksvm.cv(k, y, n.cv={ncrossv}, stats=c("accuracy"))
            }}
            cat("#{yaml}\n", file="{classifier}")
            write.tsv(results, "{classifier}", append=TRUE)

    crossv-plot:
        Extension: pdf
        Parameters:
            ntip: [100, 500, 1000]
            branch_scaling: mean
            ncrossv: 1000
            response: ["continuous"]
        Depends: classifier 
        Interpreter: R --vanilla --silent
        Startup: suppressPackageStartupMessages(library(netabc))
        Rule: |
            d <- collect.data(strsplit("{classifier}", " ")[[1]])
            if ("{response}" == "continuous") {{
                summary.plot(d, x="rbf_variance", y="rsquared", group="decay_factor", 
                             fun="mean", yaml="{yaml}")
            }} else {{
                summary.plot(d, x="rbf_variance", y="accuracy", group="decay_factor", 
                             fun="mean", yaml="{yaml}")
            }}
            ggsave("{crossv-plot}", width=10)
