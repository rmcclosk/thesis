Name: kernel-shapes
Description: Test if the tree kernel can distinguish trees from differently shaped networks
Processes: 1
Sleep: 5
Hostname: (hermes.*)|(litai.*.westgrid.ca)
Steps:
    network:
        Extension: gml.bz2
        Walltime: 00:00:30
        Parameters:
            nnode: 5000
            nsimnode: [500, 1000, 2000]
            net_type: ["BA", "ER", "WS"]
            mean_degree: 4
            ws_prob: 0.01
            pa_power: 1
            replicate: "range(100)"
        Interpreter: R --vanilla --silent
        Startup: suppressPackageStartupMessages(library(netabc))
        Rule: | 
            f <- bzfile("{network}", "wb")
            set.seed({seed})
            if ("{net_type}" == "BA") {{
                g <- sample_pa({nnode}, m={mean_degree}/2, power={pa_power}, directed=FALSE)
            }} else if ("{net_type}" == "WS") {{
                g <- sample_smallworld(1, {nnode}, {mean_degree}/2, {ws_prob})
            }} else if ("{net_type}" == "ER") {{
                g <- sample_gnp({nnode}, {mean_degree}/{nnode})
                while (length(component_distribution(g)) - 1 < {nsimnode}) {{
                    g <- sample_gnp({nnode}, {mean_degree}/{nnode})
                }}
            }}
            graph_attr(g, "comment") <- "{yaml}"
            write.graph(SIR.net(g), f, format="gml")
            close(f)

    tree:
        Extension: nwk.bz2
        Walltime: 00:00:30
        Parameters:
            mean_degree: 4
            ws_prob: 0.01
            pa_power: 1
            net_type: ["BA", "ER", "WS"]
            replicate: "range(100)"
            nsimnode: [500, 1000, 2000]
            ntip: [100, 500, 1000]
        Exclusions:
            -
                nsimnode: 500
                ntip: 1000
        Depends: network
        Interpreter: bash
        Rule: |
            NWKFILE=`echo {tree} | sed s/'.bz2'//`
            echo "#{yaml}" > $NWKFILE
            bzcat {network} | nettree --sim-nodes {nsimnode} --tree-tips {ntip} --seed {seed} >> $NWKFILE
            bzip2 $NWKFILE

    tree-plot:
        Extension: pdf
        Walltime: 00:00:30
        Parameters:
            mean_degree: 4
            ws_prob: 0.01
            pa_power: 1
            net_type: ["BA", "ER", "WS"]
            replicate: "range(3)"
            nsimnode: [500, 1000, 2000]
            ntip: [100, 500, 1000]
        Depends: tree
        Interpreter: R --vanilla --silent
        Startup: suppressPackageStartupMessages(library(netabc))
        Rule: |
            t <- ladderize(read.tree("{tree}"))
            pdf("{tree-plot}")
            par(mar=c(0, 0, 4, 0) + 0.1)
            plot(t, show.tip.label=FALSE) 
            title(paste(strwrap(as.yaml(yaml.load("{yaml}")), 60), collapse="\n"))
            dev.off()

    statistics:
        Extension: tsv
        Walltime: 00:10:00
        Sleep: 60
        Parameters:
            mean_degree: 4
            ws_prob: 0.01
            pa_power: 1
            nsimnode: [500, 1000, 2000]
            ntip: [100, 500, 1000]
        Depends: tree
        Interpreter: bash
        Rule: |
            echo "#{yaml}" > {statistics}
            echo -e "\tcolless\til.portion\tmax.ladder\tbmi\tdelta.w\twidth\tcherries\tprop.unbalanced\tavg.unbalance\tsackin\tcophenetic\tgamma" >> {statistics}
            for T in {tree}; do
                echo -n $T$'\t' >> {statistics}
                echo -n `bzcat $T | treestat -i -y -s colless`$'\t' >> {statistics}
                echo -n `bzcat $T | treestat -i -n -s il`$'\t' >> {statistics}
                echo -n `bzcat $T | treestat -i -n -s ladder`$'\t' >> {statistics}
                echo -n `bzcat $T | treestat -i -s bmi`$'\t' >> {statistics}
                echo -n `bzcat $T | treestat -i -n -s max-delta-width`$'\t' >> {statistics}
                echo -n `bzcat $T | treestat -i -n -s width`$'\t' >> {statistics}
                echo -n `bzcat $T | treestat -i -n -s cherries`$'\t' >> {statistics}
                echo -n `bzcat $T | treestat -i -s prop-unbalanced`$'\t' >> {statistics}
                echo -n `bzcat $T | treestat -i -s unbalance`$'\t' >> {statistics}
                echo -n `bzcat $T | treestat -i -y -s sackin`$'\t' >> {statistics}
                echo -n `bzcat $T | treestat -i -y -s cophenetic`$'\t' >> {statistics}
                echo `bzcat $T | treestat -i -s gamma` >> {statistics}
            done

    stats-plot:
        Extension: pdf
        Walltime: 00:00:30
        Parameters:
            mean_degree: 4
            ws_prob: 0.01
            pa_power: 1
            nsimnode: [500, 1000, 2000]
            ntip: [100, 500, 1000]
        Depends: statistics tree
        Interpreter: R --vanilla --silent
        Startup: |
            suppressPackageStartupMessages(library(netabc))
            suppressPackageStartupMessages(library(reshape2))
        Rule: |
            m <- collect.metadata(strsplit("{tree}", " ")[[1]])[,"net_type", drop=FALSE]
            m$net_type <- as.factor(m$net_type)
            d <- read.table("{statistics}", header=TRUE)
            d <- merge(m, d, by="row.names")
            d[,"Row.names"] <- NULL
            d <- melt(d, id.vars="net_type")
            ggplot(d, aes(x=net_type, y=value)) + geom_violin() + 
                facet_wrap(~variable, scales="free") + theme_bw() + 
                ggtitle(as.yaml(yaml.load("{yaml}")))
            ggsave("{stats-plot}")

    kernel-matrix:
        Extension: mtx
        Sleep: 300
        Processes: 12
        Walltime: 04:00:00
        Memory: 256m
        Parameters:
            mean_degree: 4
            ws_prob: 0.01
            pa_power: 1
            nsimnode: [500, 1000, 2000]
            ntip: [100, 500, 1000]
            decay_factor: [0.2, 0.3, 0.4]
            rbf_variance: [0.125, 0.25, 0.5, 1, 2, 5, 10, 20]
            nltt: ["yes", "no"]
        Exclusions:
            -
                ntip: 1000
                rbf_variance: [0.125, 0.25, 0.5]
            -
                ntip: [100, 500]
                rbf_variance: 20
        Depends: tree
        Interpreter: bash
        Rule: |
            if [[ "{nltt}" == "yes" ]]; then
                NLTT="--nLTT"
            else
                NLTT=""
            fi
            echo "%%MatrixMarket matrix array real symmetric" > {kernel-matrix}
            echo "%{yaml}" >> {kernel-matrix}
            echo "{$#} {$#}" >> {kernel-matrix}
            for T1 in {tree}; do
                for T2 in {tree}; do
                    if [[ "$T1" < "$T2" || "$T1" == "$T2" ]]; then
                        treekernel --ladderize --decay-factor {decay_factor} \
                                   --gauss-factor {rbf_variance} \
                                   --scale-branches mean $NLTT \
                                   <(bzcat $T1) <(bzcat $T2) >> {kernel-matrix}
                    fi
                done
            done

    kpca-plot:
        Extension: pdf
        Walltime: 00:01:00
        Parameters:
            mean_degree: 4
            ws_prob: 0.01
            pa_power: 1
            nsimnode: [500, 1000, 2000]
            ntip: [100, 500, 1000]
            decay_factor: [0.2, 0.3, 0.4]
            rbf_variance: [0.125, 0.25, 0.5, 1, 2, 5, 10, 20]
            nltt: ["yes", "no"]
        Depends: kernel-matrix tree
        Interpreter: R --vanilla --silent
        Startup: library(netabc)
        Rule: |
            k <- read.mm("{kernel-matrix}")
            y <- collect.metadata(strsplit("{tree}", " ")[[1]])[,"net_type"]
            kpca.plot(k, color=list(mean.degree=y), yaml="{yaml}")
            ggsave("{kpca-plot}")

    classifier:
        Extension: tsv
        Walltime: 03:00:00
        Sleep: 60
        Processes: 12
        Threads: 8
        Parameters:
            mean_degree: 4
            ws_prob: 0.01
            pa_power: 1
            nsimnode: [500, 1000, 2000]
            ntip: [100, 500, 1000]
            decay_factor: [0.2, 0.3, 0.4]
            rbf_variance: [0.125, 0.25, 0.5, 1, 2, 5, 10, 20]
            nltt: ["yes", "no"]
        Depends: kernel-matrix tree
        Interpreter: R --vanilla --silent
        Startup: suppressPackageStartupMessages(library(netabc))
        Rule: |
            k <- read.mm("{kernel-matrix}")
            y <- collect.metadata(strsplit("{tree}", " ")[[1]])[,"net_type"]
            results <- ksvm.cv(k, y, n.cv=1000, nthread=8, stats=c("accuracy"))
            cat("#{yaml}\n", file="{classifier}")
            write.tsv(results, "{classifier}", append=TRUE)

    crossv-plot:
        Extension: pdf
        Walltime: 00:01:00
        Parameters:
            mean_degree: 4
            ws_prob: 0.01
            pa_power: 1
            nsimnode: [500, 1000, 2000]
            ntip: [100, 500, 1000]
        Depends: classifier 
        Interpreter: R --vanilla --silent
        Startup: suppressPackageStartupMessages(library(netabc))
        Rule: |
            d <- collect.data(strsplit("{classifier}", " ")[[1]])
            summarize.plot(d, x="rbf_variance", y="accuracy", group="decay_factor", 
                           facet.x="nltt", fun="mean", yaml="{yaml}")
            ggsave("{crossv-plot}", width=10)

    kernel-parameters:
        Extension: tsv 
        Walltime: 00:01:00
        Parameters:
            placeholder: 0
        Depends: classifier 
        Interpreter: R --vanilla --silent
        Startup: suppressPackageStartupMessages(library(netabc))
        Rule: |
            d <- setDT(collect.data(strsplit("{classifier}", " ")[[1]]))
            by.cols <- tail(colnames(d, -1), -1) 
            d <- d[,mean(rsquared), by=by.cols]
            d <- d[,.SD[which.max(V1),], by=c("nsimnode", "ntip", "mean_degree", "ws_prob", "pa_power")]
            setnames(d, "V1", "rsquared")
            write.tsv(d, "{kernel-parameters}")
